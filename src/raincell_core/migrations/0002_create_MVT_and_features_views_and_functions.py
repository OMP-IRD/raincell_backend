# Generated by Django 3.2.13 on 2022-06-20 15:42

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('raincell_core', '0001_initial'),
    ]

    operations = [
        migrations.RunSQL(
            """
        --
        -- Util views
        --
        -- DROP VIEW raincell_grid CASCADE;
        CREATE OR REPLACE VIEW raincell_grid
            AS
             SELECT raincell_core_cell.id,
               st_envelope(st_buffer(raincell_core_cell.location, (0.025 / 2::numeric)::double precision))::geometry(Geometry, 4326) AS geom
           FROM raincell_core_cell;
        
            """
        ),

        migrations.RunSQL(
            """
            CREATE SCHEMA IF NOT EXISTS postgisftw;
            
            --
            -- pg_featureserv views and functions
            --
            
            -- Provides the 15m values service (& full geographic dataset too, as a bonus if you let cell_ident to NULL)
            -- Optimized version compared to above: from 6,7MB to 2.3MB for full dataset (1 day)
            
            -- Determine which view to look into, based on the cell_id pattern
            CREATE OR REPLACE FUNCTION cameroun.tablename_from_cell_id(
									tbname_prefix varchar default 'raincell_atomicrainrecord',
                                    cell_ident text default NULL, OUT tblname varchar)
            RETURNS varchar
            AS $$
            BEGIN
				-- Determine which view to look into, based on the cell_id pattern
				-- RAISE log 'cell_ident %', cell_ident;
					SELECT 
						CASE
							WHEN cell_ident LIKE 'g%' THEN
								tbname_prefix||'_sub' || LTRIM(REPLACE(SPLIT_PART(cell_ident, '_', 1), '.', ''), 'g')
							ELSE
								tbname_prefix||'_geo'
						END 
						INTO tblname;
            END;
            $$
            LANGUAGE 'plpgsql' STABLE PARALLEL SAFE;
            COMMENT ON FUNCTION cameroun.tablename_from_cell_id IS 'Determine the view containing the cell, based on the cell''s cell_id';
            
						
            CREATE OR REPLACE FUNCTION postgisftw.rain_at_time_and_cell(
                                    cell_ident text default NULL,
                                    ref_time text default '2022-06-14T23:55:00+00:00',
                                    duration text default '1 days')
            RETURNS TABLE(cell_id VARCHAR, rc_data JSON, id VARCHAR, geom geometry)
            AS $$
            DECLARE
                tblname text;
            BEGIN
				-- Determine which view to look into, based on the cell_id pattern
				tblname := (SELECT cameroun.tablename_from_cell_id('raincell_atomicrainrecord',cell_ident));
				-- Retrieve and aggregate the data
                RETURN QUERY
                EXECUTE format('
                    WITH
                    agg1 AS (
                        SELECT r.cell_id, to_char(r.recorded_time, ''YYYYMMDD'') AS d, json_agg(json_build_object(
                                  ''t'', to_char(r.recorded_time, ''HH24MI''),
                                  ''q25'',r.quantile25,
                                  ''q50'',r.quantile50,
                                  ''q75'',r.quantile75
                                )
                                ORDER BY r.recorded_time) AS v,
                                r.geom
                        FROM %I AS r
                            WHERE (r.recorded_time BETWEEN $2::timestamp  - $3::interval AND $2::timestamp )
                            AND ($1 IS NULL OR r.cell_id = $1)
                        GROUP BY r.cell_id, to_char(r.recorded_time, ''YYYYMMDD''), r.geom
                   )
                    SELECT r.cell_id, json_agg(json_build_object(''d'', r.d, ''v'', r.v) ORDER BY r.d) AS rc_data, r.cell_id AS id, r.geom
                        FROM agg1 AS r
                        GROUP BY r.cell_id, r.geom;
                ', tblname)
                USING cell_ident, ref_time, duration;
            END;
            $$
            LANGUAGE 'plpgsql' STABLE PARALLEL SAFE;
            
            
            COMMENT ON FUNCTION postgisftw.rain_at_time_and_cell IS 'Returns the rain on the given datetime, with a history period defined by duration parameter (defaults 2 days). Results limited to the cell_ident value, unless set to NULL (default) in which case it will return the full geospatial dataset (all cells), which represent several MB. ref_time is expected as a full datetime character string (e.g. "2022-06-14T23:55:00+00:00". But be aware that you might have, in case of passing this parameter from a browser URL, to escape it: in that case, replace the "+" by "%2B")';
            
            
            -- DROP FUNCTION postgisftw.rain_at_time;
            CREATE OR REPLACE FUNCTION postgisftw.rain_at_time(
                                    ref_time text default '2022-06-14T23:55:00+00:00',
                                    duration text default '2 days')
            RETURNS TABLE(cell_id VARCHAR, rc_data JSON, id VARCHAR, geom geometry)
            AS $$
            BEGIN
                RETURN QUERY
                    SELECT * FROM postgisftw.rain_at_time_and_cell(NULL, ref_time, duration);
            END;
            $$
            LANGUAGE 'plpgsql' STABLE PARALLEL SAFE;
            COMMENT ON FUNCTION postgisftw.rain_at_time IS 'Returns the rain on the given datetime, with a history period defined by duration parameter (defaults 2 days). Is just a special case of rain_at_time_and_cell, where cell_ident is not a variable anymore (set to NULL => all the dataset is returned)';
            
                        
            -- Provides the daily values service (& full geographic dataset too, as a bonus if you let cell_ident to NULL)
            CREATE OR REPLACE FUNCTION postgisftw.rain_daily_at_date_and_cell(
                                    cell_ident text default NULL,
                                    ref_date date default '2022-06-14',
                                    duration text default '50 days')
            RETURNS TABLE(cell_id VARCHAR, rc_data JSON, id VARCHAR, geom geometry)
            AS $$
            DECLARE
                tblname text;
            BEGIN
                -- Determine which view to look into, based on the cell_id pattern
                tblname := (SELECT cameroun.tablename_from_cell_id('raincell_daily_records', cell_ident));
                -- Retrieve and aggregate the data
                RETURN QUERY
                EXECUTE format('
                    WITH
                    aggregated_records AS (
                        SELECT r.cell_id, json_agg(json_build_object(''d'', r.recorded_date, 
                                    ''q25'',r.quantile25,
                                    ''q50'',r.quantile50,
                                    ''q75'',r.quantile75
                                  )
                                  ORDER BY r.recorded_date) AS rc_data,
                                  r.cell_id AS id,
                                r.geom
                        FROM %I AS r
                        WHERE (r.recorded_date BETWEEN $2::date  - $3::interval AND $2::date)
                          AND ($1 IS NULL OR r.cell_id = $1)
                        GROUP BY r.cell_id, r.geom
                    )
                    SELECT *  FROM aggregated_records ;
                ', tblname)
                USING cell_ident, ref_date, duration;
            END;
            $$
            LANGUAGE 'plpgsql' STABLE PARALLEL SAFE;
            
            COMMENT ON FUNCTION postgisftw.rain_daily_at_date_and_cell IS 'Returns the daily rain (mean over the day) on the given day, with a history period defined by duration parameter (defaults "50 days"). Results limited to the cell_ident value, unless set to NULL (default) in which case it will return the full geospatial dataset (all cells), which represent several MB. Beware that the duration needs to be a postgresq interval, as defined in https://www.postgresql.org/docs/14/datatype-datetime.html. E.g. "50 days", which is very different from "50" (no unit)';

            """
        ),

        migrations.RunSQL(
            """   
            --
            --
            -- Creating and managing subsampled data (lower resolution grids)
            --
            
            -- subsampled grid generation function
            CREATE OR REPLACE FUNCTION raincell_grid_subsample(
                cell_size float default 0.5
            )
            RETURNS TABLE(id VARCHAR, geom geometry)
                AS
                $$
            BEGIN
                RETURN QUERY
                    WITH ext AS (
                            SELECT ST_SetSRID(ST_Extent(raincell_grid.geom),4326) AS geom FROM raincell_grid
                        ),
                        grid_sub AS (
                            SELECT (ST_SquareGrid(cell_size, ST_Transform(ext.geom,4326))).*
                            FROM ext
                        )
                    SELECT DISTINCT ('g'||cell_size::text||'_'||a.i||'_'||a.j)::varchar AS id, a.geom::geometry(Geometry, 4326) FROM grid_sub a, raincell_core_cell b WHERE ST_Intersects(a.geom,b.location);
            END;
            $$
            LANGUAGE 'plpgsql' STABLE PARALLEL SAFE;
            
            
            -- Create a view exposing the original data, but spatialized
            CREATE OR REPLACE VIEW raincell_atomicrainrecord_geo AS
            SELECT r.cell_id, r.recorded_time, r.quantile25, r.quantile50, r.quantile75, g.geom
            FROM raincell_core_atomicrainrecord r INNER JOIN raincell_grid g
            ON r.cell_id = g.id;
            
            -- drop view raincell_daily_records_geo CASCADE;
            CREATE OR REPLACE VIEW raincell_daily_records_geo
                AS
                SELECT cell_id, recorded_time::date AS recorded_date, ROUND(AVG(quantile25)::NUMERIC, 2) AS quantile25, ROUND(AVG(quantile50)::NUMERIC, 2) AS quantile50, ROUND(AVG(quantile75)::NUMERIC, 2) AS quantile75, geom::geometry(Geometry, 4326)
                FROM raincell_atomicrainrecord_geo
                GROUP BY cell_id, recorded_time::date, geom
                ORDER BY cell_id,recorded_date;
            
            --
            -- Procedure, that automatically builds
            --  - the subsampled geo grids (no data). Names of kind raincell_grid_sub{cell_size_string}
            --  - the atomic data on those subsampled geo grid (no time-based aggregate). Names of kind raincell_atomicrainrecord_sub{cell_size_string}
            -- where cell_size_string is made out of cell_size var, but removing the ".".
        
            CREATE OR REPLACE PROCEDURE raincell_grid_make_subsample_views()
                AS
                $$
            DECLARE
               cell_size  float;
            BEGIN
                FOREACH cell_size IN ARRAY ARRAY[0.05, 0.1, 0.2, 0.4, 0.8] LOOP
                    --EXECUTE format('DROP VIEW %I CASCADE', 'raincell_grid_sub' || replace(cell_size::text, '.',''));
                    EXECUTE format('CREATE OR REPLACE VIEW  %I  AS SELECT id, geom::geometry(Geometry, 4326) FROM raincell_grid_subsample(%L)', 'raincell_grid_sub' || replace(cell_size::text, '.',''), cell_size);
                    --EXECUTE format('DROP VIEW %I', 'raincell_atomicrainrecord_sub' || replace(cell_size::text, '.',''));
                    EXECUTE format('
                        -- create subsampled data as views
                        CREATE OR REPLACE VIEW %I AS
                        WITH geo_records AS (
                            SELECT t.*, g.location
                            FROM raincell_core_atomicrainrecord t, raincell_core_cell g
                            WHERE t.cell_id = g.id
                        )
                        SELECT g.id AS cell_id, r.recorded_time, round(avg(r.quantile25)::numeric,2) AS quantile25, round(avg(r.quantile50)::numeric,2) AS quantile50, round(avg(r.quantile75)::numeric, 2) AS quantile75, g.geom::geometry(Geometry, 4326)
                        FROM geo_records r, %I g
                        WHERE ST_contains(g.geom, r.location)
                        GROUP BY r.recorded_time, g.id, g.geom;',
                  'raincell_atomicrainrecord_sub' || replace(cell_size::text, '.',''),
                  'raincell_grid_sub' || replace(cell_size::text, '.','')
                  );
                  -- subsample daily data
                  EXECUTE format('
                      -- create subsampled data as views
                      CREATE OR REPLACE VIEW %I AS
                      SELECT g.id AS cell_id, r.recorded_date, round(avg(r.quantile25)::numeric,2) AS quantile25, round(avg(r.quantile50)::numeric,2) AS quantile50, round(avg(r.quantile75)::numeric, 2) AS quantile75, g.geom::geometry(Geometry, 4326)
                      FROM raincell_daily_records_geo r, %I g
                      WHERE ST_contains(ST_centroid(g.geom), r.geom)
                      GROUP BY r.recorded_date, g.id, g.geom;',
                'raincell_daily_records_sub' || replace(cell_size::text, '.',''),
                'raincell_grid_sub' || replace(cell_size::text, '.','')
                );
            
                END LOOP;
            END
            $$
            LANGUAGE 'plpgsql';
            
            -- execute the procedure
            CALL raincell_grid_make_subsample_views();
            """
        ),
        migrations.RunSQL(
            """   
            --
            -- MVT functions
            --
            -- fetches data from subsample datasets based on zoom level
            -- DROP FUNCTION mvt_rain_cells_for_time;
            CREATE OR REPLACE
            FUNCTION mvt_rain_cells_for_time(
                        z integer, x integer, y integer,
                        ref_time text default '2022-06-14T23:55:00+00:00',
                        duration text default '1 day')
            RETURNS bytea
            AS $$
            DECLARE
                tblname text;
                result bytea;
            BEGIN
                CASE
                    WHEN z < 3 THEN
                        tblname := 'raincell_atomicrainrecord_sub08';
                    WHEN z < 5 THEN
                        tblname := 'raincell_atomicrainrecord_sub04';
                    WHEN z < 6 THEN
                        tblname := 'raincell_atomicrainrecord_sub02';
                    WHEN z < 7 THEN
                        tblname := 'raincell_atomicrainrecord_sub01';
                    WHEN z < 8 THEN
                        tblname := 'raincell_atomicrainrecord_sub005';
                    ELSE
                        tblname := 'raincell_atomicrainrecord_geo';
                END CASE;
              EXECUTE format('
                WITH
                bounds AS (
                  SELECT ST_TileEnvelope($3, $1, $2) AS geom
                ),
                agg1 AS (
                        SELECT r.cell_id, to_char(r.recorded_time, ''YYYYMMDD'') AS d, json_agg(json_build_object(''t'', to_char(r.recorded_time, ''HH24MI''), ''v'', r.quantile50) ORDER BY to_char(r.recorded_time, ''HH24MI'')) AS rc_data, r.geom
                        FROM %I AS r
                        WHERE r.recorded_time BETWEEN $4::timestamp  - $5::interval AND $4::timestamp
                        GROUP BY cell_id, to_char(r.recorded_time, ''YYYYMMDD''), r.geom
                ),
                agg2 AS (
                    SELECT r.cell_id, json_agg(json_build_object(''d'', r.d, ''v'', r.rc_data) ORDER BY r.d) AS rc_data, r.geom, ''%I'' AS tblname
                    FROM agg1 AS r
                    GROUP BY r.cell_id, r.geom
                ),
                mvtgeom AS (
                  SELECT t.cell_id, t.tblname, ST_AsMVTGeom(ST_Transform(t.geom, 3857), bounds.geom) AS geom,
                    t.rc_data
                  FROM agg2 t, bounds
                  WHERE ST_Intersects(t.geom, ST_Transform(bounds.geom, 4326))
                )
                SELECT ST_AsMVT(mvtgeom, ''default'')
            
                FROM mvtgeom;
                ', tblname, tblname)
                USING x, y, z, ref_time, duration
                INTO result;
            
                RETURN result;
            END;
            $$
            LANGUAGE 'plpgsql'
            STABLE
            PARALLEL SAFE;

            
            COMMENT ON FUNCTION mvt_rain_cells_for_time IS 'Returns MVT. Aggregates data for the given datetime, with a history period defined by duration parameter (defaults 1 day).  Depending on the zoom level, the data will be aggregated into larger cells, to avoid sending huge VT. ref_time is expected as a full datetime character string (e.g. "2022-06-14T23:55:00+00:00". But be aware that you might have, in case of passing this parameter from a browser URL, to escape it: in that case, replace the "+" by "%2B"';

            """
        ),
    ]
